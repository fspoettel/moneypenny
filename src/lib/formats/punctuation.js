const { fmtTime } = require('../helpers')

function needsZeroSub (flag, index, timeStart) {
  return flag && index === 0 && timeStart !== '00:00:00,000'
}

function addZeroSub (timeStart) {
  return `1\n00:00:00,000 --> ${timeStart}\nAutomatically generated by moneypenny\n\n`
}

function encodeResult ({ results }, forceSubAtZero) {
  const allWords = results
    .reduce((acc, curr) => {
      const { alternatives } = curr
      if (!Array.isArray(alternatives) || alternatives.length === 0) return acc

      const { words } = alternatives[0]
      if (!Array.isArray(words) || !words[0]) return acc

      return [...acc, ...words]
    }, [])

  const res = allWords
    .reduce((acc, curr) => {
      const { sentenceBuffer, content, index } = acc

      const isEnd = /\.|\?|!/.test(curr.word)
      const isNewSentence = sentenceBuffer.length === 0
      sentenceBuffer.push(curr.word)

      if (isEnd) {
        const timeEnd = fmtTime(curr.endTime)
        return {
          ...acc,
          sentenceBuffer: [],
          content: `${content} --> ${timeEnd}\n${sentenceBuffer.join(' ')}\n\n`
        }
      }

      if (isNewSentence) {
        const timeStart = fmtTime(curr.startTime)
        const isZeroSub = needsZeroSub(forceSubAtZero, index, timeStart)
        const nextIndex = isZeroSub ? index + 2 : index + 1
        const passage = `${nextIndex}\n${timeStart}`

        return {
          index: nextIndex,
          sentenceBuffer,
          content: isZeroSub
            ? `${addZeroSub(timeStart)}${passage}`
            : `${content}${passage}`
        }
      }

      return { ...acc, sentenceBuffer }
    }, {
      sentenceBuffer: [],
      content: '',
      index: 0
    })

  return res.content
}

function encodeDiarizedResult ({ results }, forceSubAtZero) {
  const lastResult = results[results.length - 1]
  const { words } = lastResult.alternatives[0]

  const { bySpeaker } = words
    .reduce((acc, curr) => {
      const { bySpeaker, lastSpeakerTag } = acc

      const speakerTag = curr.speakerTag
      const hasSpeakerChanged = lastSpeakerTag !== speakerTag

      if (!hasSpeakerChanged) {
        bySpeaker[bySpeaker.length - 1].push(curr)
        return acc
      }

      bySpeaker.push([curr])
      return { lastSpeakerTag: speakerTag, bySpeaker }
    }, {
      lastSpeakerTag: null,
      bySpeaker: []
    })

  const res = bySpeaker
    .reduce((acc, curr, i) => {
      if (curr.length === 0) return acc

      let { content, index } = acc
      let sentenceBuffer = []

      const currentSpeaker = curr[0].speakerTag

      curr.forEach(({ word, startTime, endTime }, j) => {
        const isNewSentence = sentenceBuffer.length === 0
        const isLast = j === curr.length - 1
        const isEnd = /\.|\?|!/.test(word)
        const isZeroSub = needsZeroSub(forceSubAtZero, i + j, startTime)

        sentenceBuffer.push(word)

        if (isZeroSub) {
          index += 1
          content = `${addZeroSub(fmtTime(startTime))}`
        }

        if (isNewSentence && !isLast) {
          index += 1
          content = `${content}${index}\n${fmtTime(startTime)} --> `
        } else if (isEnd || isLast) {
          if (isNewSentence) {
            index += 1
            content = `${content}${index}\n${fmtTime(startTime)} --> `
          }
          content = `${content}${fmtTime(endTime)}\n[Speaker ${currentSpeaker}] ${sentenceBuffer.join(' ')}\n\n`
          sentenceBuffer = []
        }
      })

      return { content, index }
    }, { content: '', index: 0 })

  return res.content
}

module.exports = {
  encodeResult, encodeDiarizedResult
}
