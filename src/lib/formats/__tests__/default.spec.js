const { getMockResult, getMockDiarizedResult, TRANSCRIPT_FIXTURES_DIARIZED, TRANSCRIPT_FIXTURES } = require('./testHelpers')
const { encodeResult, encodeDiarizedResult } = require('../default')

const hasZeroSub = (str, endTime) => str.startsWith(`1\n00:00:00,000 --> ${endTime}\nAutomatically generated by moneypenny\n\n`)

describe('format.default', () => {
  describe('encodeResult()', () => {
    describe('when results are empty', () => {
      it('returns an empty string', () => {
        const response = TRANSCRIPT_FIXTURES.EMPTY
        expect(encodeResult(response)).toEqual('')
      })
    })

    describe('when results are not empty', () => {
      it('returns a formatted `.srt` file', async () => {
        const response = await getMockResult()
        expect(encodeResult(response)).toMatchSnapshot()
      })

      it('returns a formatted `.srt` file when only one word is present', async () => {
        const response = TRANSCRIPT_FIXTURES.SINGLE_WORD
        expect(encodeResult(response)).toMatchSnapshot()
      })
    })

    describe('when params.forceSubAtZero is set', () => {
      it('adds a sub in first place', async () => {
        const response = await getMockResult()
        expect(hasZeroSub(encodeResult(response, true), '00:00:02,300')).toBeTruthy()
      })

      it('does not add a sub in first place if first result starts at 0', () => {
        const response = TRANSCRIPT_FIXTURES.SINGLE_WORD
        expect(encodeResult(response, true).includes('moneypenny')).toBeFalsy()
      })
    })
  })

  describe('encodeDiarizedResult()', () => {
    describe('when results are empty', () => {
      it('returns an empty string', () => {
        const response = { results: [] }
        expect(encodeDiarizedResult(response)).toEqual('')
      })
    })

    describe('when results are not empty', () => {
      it('returns a formatted `.srt` file', async () => {
        const response = await getMockDiarizedResult()
        expect(encodeDiarizedResult(response)).toMatchSnapshot()
      })

      it('returns a formatted `.srt` file when there is only one word on the transcript', () => {
        const response = TRANSCRIPT_FIXTURES_DIARIZED.SINGLE_WORD
        expect(encodeDiarizedResult(response)).toMatchSnapshot()
      })

      it('returns a formatted `.srt` file when speaker never changes', () => {
        const response = TRANSCRIPT_FIXTURES_DIARIZED.SPEAKER_CONSTANT
        expect(encodeDiarizedResult(response)).toMatchSnapshot()
      })
    })

    describe('when params.forceSubAtZero is set', () => {
      it('adds a sub in first place', async () => {
        const response = await getMockDiarizedResult()
        expect(hasZeroSub(encodeDiarizedResult(response, true), '00:00:02,300')).toBeTruthy()
      })

      it('does not add a sub in first place if first result starts at 0', () => {
        const response = TRANSCRIPT_FIXTURES_DIARIZED.SINGLE_WORD
        expect(encodeDiarizedResult(response, true).includes('moneypenny')).toBeFalsy()
      })
    })
  })
})
